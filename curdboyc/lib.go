package curdboyc

import(
	"embed"
	"path"
	//"log"
	"os"
	"github.com/fatih/color"
	"fmt"
 ent "github.com/pigfall/ent_utils"
 
	"golang.org/x/tools/go/packages"
)

//go:embed tpls/*
var templates embed.FS


type CURDGraphGenerator struct{
	config *Config
	Graph *ent.Graph
	Module  *packages.Module // the user's module
	CURDBoyModuelPath string
	EdgesOfNodes map[string]*EdgesOfNode // node name => EdgesOfNode 
}


func LoadCURDGraphGenerator (config *Config)(*CURDGraphGenerator, error){
	r := &CURDGraphGenerator{
		config:config,
		CURDBoyModuelPath: "github.com/pigfall/curdboy",// TODO query by program
	}
	err := r.init()
	if err != nil {
		return nil, err
	}

	return r,nil
}

func (this *CURDGraphGenerator) init() error {
	// { load ent graph
	graph,err := ent.LoadGraph(this.config.entSchemaDirPath)
	if err != nil {
		err = fmt.Errorf("Failed to load ent graph from dir path < %s >: < %s > \n",color.New(color.FgRed).SprintFunc()(this.config.entSchemaDirPath),color.New(color.FgRed).SprintFunc()(err.Error()))
		return err
	}
	// }

	this.Graph = graph

	// {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedModule,
	}, this.config.entSchemaDirPath)
	if len(pkgs) == 0{
		return fmt.Errorf("Failed to get module path")
	}
	module :=  pkgs[0].Module
	if module == nil{
		return fmt.Errorf("Unexpected module is nil")
	}
	if len(module.Path )== 0{
		return fmt.Errorf("Unexpected module path is empty")
	}
	this.Module = module
	// }

	err = os.MkdirAll(this.TargetDirPath(),os.ModePerm)
	if err != nil{
		return fmt.Errorf("Failed to mkdir for target path %s",this.TargetDirPath())
	}

	// { 
	err = this.parseEdgeAlias()
	if err != nil{
		return err
	}

	// }

	return nil
}


// top generate function to generate curdboy core code
func (this *CURDGraphGenerator) Generate() error{
	err := os.MkdirAll(this.TargetDirPath(),os.ModePerm)
	if err != nil{
		return fmt.Errorf("Failed to mkdir for target path %s",this.TargetDirPath())
	}

	// { generate curd param
	err = NewCURDParamGenerator(this).Generate()
	if err != nil{
		err = fmt.Errorf("Failed to generate curd parma code: < %s> ",color.New(color.FgRed).SprintFunc()(err.Error()))
		return err
	}

	// }

	// { generate curd for each node
	for _,node := range this.Graph.GetNodes(){
		err := NewCURDNodeGenerator(node,this).Generate()
		if err != nil{
			return err
		}
	}
	// }

	return nil
}

func (this *CURDGraphGenerator) Generated_QueryRequestStructName() string{
	return `QueryRequest`
}

// which directory path to save the generated files
func (this *CURDGraphGenerator) TargetDirPath()string{
	return this.config.targetDirPath
}

func (this *CURDGraphGenerator) GeneratedPrelude()string{
	return `do not edit, auto generated by curdboy`
}

func (this *CURDGraphGenerator) GeneratedPkgName() string{
	return "curd"
}

//eg: package ent_generated
func (this *CURDGraphGenerator) EntPkgName() string {
	return path.Base(this.config.entTargetDirPath)
}

// eg: <project>/ent/ent_generated
func (this *CURDGraphGenerator) EntPkgPath() string{
	return path.Join(this.Module.Path,this.config.entTargetDirPath)
}

func (this *CURDGraphGenerator) Generated_PkgPath() string{
	return path.Join(this.Module.Path,this.TargetDirPath())
}

// 
func (this *CURDGraphGenerator) FilterParserPkgPath() string{
	return path.Join(this.CURDBoyModuelPath,"pkgs/filter")
}

func (this *CURDGraphGenerator) EntPredicatePkgPath() string{
	return path.Join(this.EntPkgPath(),"predicate")

}

func (this *CURDGraphGenerator) parseEdgeAlias()error{
	var edgesOfNodes = make(map[string]*EdgesOfNode)
	for _,node := range this.Graph.GetNodes(){
		INNER:
		for _,edge := range node.Edges {
			ans,err := GetAnnotation(edge)
			if err != nil{
				panic(err)
			}
			if ans == nil {
				continue INNER
			}
			for _,an := range ans.List{
				edgesOfNode := findOrInsertEdgesOfNode(&edgesOfNodes,node)

				if len(an.Left) > 0{
					edgesOfNode.AddEdgeAlias(an.Left,ent.FromEntEdge(edge))
				}

				// { add inverse edge alias TODO, must satif

				inverseNode := ent.FromType(edge.Type)
				edgesOfNode = findOrInsertEdgesOfNode(&edgesOfNodes,inverseNode)

				if len(an.Right) >0 {
					if len(an.FromName)==0 {
						panic(fmt.Errorf("TODO with right alias, the from name must speicified"))
					}
					// && TODO check schema set the inverse edge

					var matchedEdge *ent.Edge // find edge
					for _,edge := range inverseNode.Edges{
						if edge.Name == an.FromName{
							matchedEdge = ent.FromEntEdge(edge)
							break
						}
					}

					if matchedEdge == nil{
						// TODO
						panic(fmt.Errorf("NOT FOUND inverse edge %s from node %s",an.FromName,inverseNode.Name()))
					}

					edgesOfNode.AddEdgeAlias(an.Right,matchedEdge)
				}

			}
			// }
		}
	}
	this.EdgesOfNodes = edgesOfNodes
	return nil
}

func (this *CURDGraphGenerator) GetEdgesAlias(nodeName string)[]*EdgeAlias{
	edgesOfNode := this.EdgesOfNodes[nodeName]
	if edgesOfNode == nil{ // no edges
		return nil
	}
	return edgesOfNode.Aliases
}

func findOrInsertEdgesOfNode(edgesOfNodes *map[string]*EdgesOfNode,node *ent.Type)*EdgesOfNode{
	edgesOfNode := (*edgesOfNodes)[node.Name()]
	if edgesOfNode == nil{
		edgesOfNode = NewEdgesOfNode(node)
		(*edgesOfNodes)[node.Name()] = edgesOfNode
	}
	return edgesOfNode
}
